# 功能PRD：窗口跨屏移动

> 版本: 1.0
>
> 功能负责人: Gemini

## 1. 背景

用户在拥有多个显示器的 Windows 环境下工作时，频繁需要将当前活动的窗口（例如浏览器、代码编辑器）从一个显示器移动到另一个显示器。当前通过鼠标拖拽的方式效率低下，且容易误操作。

参考业界成熟的窗口管理软件 **DisplayFusion**，我们计划开发一个轻量级的功能，允许用户通过一个全局快捷键，快速地将当前窗口“发送”到下一个显示器，以提升多屏工作的流体度和效率。

## 2. 目标

- **核心目标**: 实现一个后台服务，监听全局快捷键。
- **功能目标**: 当快捷键被触发时，程序能识别当前活动窗口，并将其完整地移动到下一个显示器。
- **易用性目标**: 快捷键应支持用户自定义，以避免与其它软件冲突。
- **集成目标**: 该功能将作为现有 `desktop-visual-timer` 应用的一个模块，随主程序启动。

## 3. 功能描述

### 3.1. 核心逻辑

1.  **显示器识别**: 每次触发快捷键时，程序会实时检测并获取所有已连接显示器的信息，包括分辨率、位置（坐标）和主次关系。这确保了在程序运行时插拔显示器，功能依然正常。
2.  **获取当前窗口**: 当用户按下指定快捷键时，程序会捕获到当前拥有焦点的顶层窗口（Foreground Window）。
3.  **定位当前窗口**: 程序判断当前窗口主要位于哪个显示器。这通常通过计算窗口中心点或大部分面积所在的显示器来确定。
4.  **计算目标位置**:
    -   程序在内部的显示器列表中找到“下一个”显示器。例如，如果有两个显示器（1和2），当前窗口在1上，则下一个是2；当前在2上，则下一个是1，形成一个循环。
    -   程序计算窗口在目标显示器上的新坐标。为了保持用户体验，移动后的窗口大小应保持不变，并尽量在目标显示器上居中或以相似的相对位置显示。
    -   一个简单的策略是：`新X = 目标显示器左上角X + (目标显示器宽度 - 窗口宽度) / 2`，`新Y = 目标显示器左上角Y + (目标显示器高度 - 窗口高度) / 2`。
5.  **移动窗口**: 程序调用系统API，将窗口移动到计算出的新位置。

### 3.2. 用户交互

- 用户在任何时候按下设定的快捷键（例如 `F12`），当前活动窗口就会立即移动到下一个显示器。
- 整个过程无UI界面，操作通过后台完成，追求“静默”和“高效”。

### 3.3. 配置项

为了实现自定义快捷键，我们将在 `settings.json` 文件中增加一个新配置项。

```json
{
  // ... a
  "move_window_hotkey": "F12"
}
```

用户可以通过修改这个值来改变快捷键。程序需要能够解析常见的键位名（如 `F1` - `F12`, `Ctrl`, `Alt`, `Shift` 等组合键）。

## 4. 技术实现方案（初步）

### 4.1. 依赖库

- **`pywin32`**: 强大的与 Windows API 交互的库。是实现此功能的核心。
    -   `win32gui.GetForegroundWindow()`: 获取当前活动窗口的句柄。
    -   `win32gui.GetWindowRect()`: 获取窗口的位置和大小。
    -   `win32gui.SetWindowPos()`: 设置窗口的位置。
    -   `win32api.EnumDisplayMonitors()`: 枚举所有显示器及其信息。
- **`pynput`** 或 **`keyboard`**: 用于监听全局快捷键。这两个库比 `pywin32` 的 `RegisterHotKey` 更易于在 Python 脚本中实现和管理。

### 4.2. 实现步骤

1.  **更新依赖**: 在 `requirements.txt` 中添加 `pynput` 和 `pywin32`。
2.  **创建新模块**: 在 `src` 目录下创建一个新文件，例如 `src/window_manager.py`，用于封装所有与窗口管理相关的功能。
3.  **实现窗口移动逻辑**: 在 `window_manager.py` 中编写一个核心函数，如 `move_active_window_to_next_monitor()`，完成上述“核心逻辑”中描述的所有步骤。
4.  **实现热键监听**: 在 `window_manager.py` 中编写一个类或函数，用于启动和管理全局热键的监听。当热键被按下时，调用 `move_active_window_to_next_monitor()`。
5.  **集成到主程序**: 修改 `src/main.py`。在程序启动时，从 `settings.json` 读取快捷键配置，并初始化和启动 `window_manager` 的热键监听器。监听器应在单独的线程中运行，以避免阻塞主程序的GUI事件循环。
6.  **更新设置模块**: 修改 `src/settings_manager.py` 以支持读取和验证 `move_window_hotkey` 配置。

## 5. 非功能性需求

- **性能**: 后台监听进程的CPU和内存占用应极低。
- **兼容性**: 仅支持 Windows 平台。
- **稳定性**: 即便在移动某些特殊窗口（如无边框、全屏）时，程序也应保持稳定，不应崩溃。

## 6. 验收标准 (AC)

- [ ] 当程序运行时，按下设定的快捷键，当前活动窗口会移动到下一个显示器。
- [ ] 窗口移动功能支持至少两个显示器，并能正确循环。
- [ ] 窗口移动后，其尺寸保持不变。
- [ ] 可以在 `settings.json` 中成功自定义快捷键，程序能正确识别并应用新快捷键。
- [ ] 该功能作为后台线程运行，不影响主计时器应用的正常使用。

## 7. 潜在风险与问题

- **对最大化窗口的处理**: 直接移动最大化的窗口可能会导致其变为“还原”状态。需要特殊处理：先将窗口还原，移动后，再在新的显示器上将其最大化。
- **权限问题**: 如果目标窗口是以管理员权限运行的，而我们的程序不是，可能没有权限移动它。
- **快捷键冲突**: 用户设置的快捷键可能与系统或其他软件的全局快捷键冲突。需要在文档中提示用户。
- **对全屏游戏/应用的处理**: 移动一个全屏的应用可能会导致该应用显示异常或退出全屏。此为已知限制，初期可不作重点处理。
